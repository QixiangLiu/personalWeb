<!DOCTYPE html>
<html>
<head>
  <title>EECS 368</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width initial-scale=1.0">
  <meta name ="author" content="QixiangLiu">
</head>

<body>
  <h3>Chpater 6 Objects</h3>
  <h3>Chapter 10 Modules</h3>
  <p>
    Modules: 指实现某特定功能的一组方法和代码. eg: CommonJS，C “include”<br>
    模块模式使用了 JavaScript 的一个特性，即闭包（Closures) <br>
    模块的重要性：因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块.<br>
    要确保模块的合理分割则须了解信息隐藏，内聚度及耦合度。(dependencies, interface)<br>
    <a href="http://www.ruanyifeng.com/blog/javascript/">阮一峰老师的JavaScript</a><br>
    Important!<a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">Modules（1）</a><br>
    <a href="http://web.jobbole.com/83761/">模块化进程</a>
    基本模版：<br>
      ;(function (参数) { <br>
      // 模块代码 <br>
      // return something;<br>
      })(参数);<br>
    eg><br>
      const weekDay = function() { <br>
        const names = ["Sunday", "Monday", "Tuesday", "Wednesday",
                       "Thursday", "Friday", "Saturday"];//变量不可见<br>
          return {//接口给外面使用<br>
              name(number) { return names[number]; }, <br>
              number(name) { return names.indexOf(name); } <br>
          };<br>
      }();<br>
    console.log(weekDay.name(weekDay.number("Sunday")));<br>
    require（导入） to access their dependencies, and put their interface in the object
    bound to exports（导出）.<br>
    node.js规范了CommonJS
    1. 模块的标识应遵循的规则（书写规范）<br>
    2. 定义全局函数require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的API<br>
    3. 如果被require函数引入的模块中也包含依赖，那么依次加载这些依赖<br>
    4. 如果引入模块失败，那么require函数应该报一个异常<br>
    5. 模块通过变量exports来向往暴漏API，exports只能是一个对象，暴漏的API须作为此对象的属性。<br>

  </p>
  <h3>Chapter 13 Asynchronous Programming</h3>
  <p>
    <h4>import {} from </h4>
    <a href="http://es6.ruanyifeng.com/#docs/module#export">阮一峰老师ECMAScript 6</a>
    export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口 <br>
    import用于在一个模块中加载另一个含有export接口的模块。<br>
    也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。<br>
  </p>
  <p>
    <h4>JavaScript require()</h4>
          每个模块实例都有一个require 方法<br>
          用来搜索文件或者文件夹的,调用模块<br>
          当 Node 遇到 require(X) 时，按下面的顺序处理。<br>
      （1）如果 X 是内置模块（比如 require('http'）) <br>
      　　a. 返回该模块。 <br>
      　　b. 不再继续执行。<br>
      （2）如果 X 以 "./" 或者 "/" 或者 "../" 开头 <br>
      　　a. 根据 X 所在的父模块，确定 X 的绝对路径。 <br>
      　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br>
  </p>
  <p>
    <h4>Callback</h4>
      setTimeout()方法只运行一次，也就是说当达到设定的时间后就出发运行指定的代码，运行完后就结束了，
      如果还想再次执行同样的函数，可以在函数体内再次调用setTimeout()，可以达到循环调用的效果。
      setInterval()是循环执行的，即每达到指定的时间间隔就执行相应的函数或者表达式，是真正的定时器。
    <h4>Promise</h4>
    <a href="https://www.cnblogs.com/nullcc/p/5841182.html">Link to Asyn Pro</a><br>
    为CommonJS 提供统一的接口
  </p>
  <p>
    <h4>Generator 函数</h4>
    最大的特点：交出函数的执行权 （暂停执行）！<br>
    yield: 异步操作需要暂停的地方 <br>
    Generator函数的函数名前面有一个"*" <br>
  </p>
  <p>
    <h4>async and await</h4>
    <a href="https://blog.csdn.net/sinat_17775997/article/details/76481923">Link to async</a>
    async(异步) 函数变体 <br>
    async(异步) 函数总是返回 Promises <br>
    通过 await 处理 async(异步) 计算的结果和错误 <br>
  </p>
</body>
</html>
