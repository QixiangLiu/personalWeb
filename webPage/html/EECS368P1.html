<!DOCTYPE html>
<html>
<head>
  <title>EECS 368</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width initial-scale=1.0">
  <meta name ="author" content="QixiangLiu">
</head>

<body style="padding:20px;">
  <h2 id="C3C5">Eloquent JavaScript language->web development</h2>
  <p>
    JS Do:<br>
    1) Improve user interations <br>
    2) Check form, table in order to save time<br>
    3) Create dynamic website, eg. attach a document to the email<br>
    4) Set up Cookie (Cookie is some temporary infomation that store in website)<br>
    eg. browser history, username.<br>
    JS Cannot:<br>
    1) Cannot be allowed to read or write computer's files.<br>
    2) Cannot be allowed to modify server's files.<br>
    3) Cannot close windows that do not belong JS.<br>
    4) Donot read other websites. (JS donot know what you visit in websits);<br>
    JS is hard to learn because JS is a lot of small knowledge.<br>
  </p>
  <h3>Chapter 3 and 5: Function and High Order Function</h3>
  <p>
    Definition of Functions(3 ways):<br>
    1) Cannot be hoisted: const square = function(x){return x*x;}; <strong>if have no return, return undefined;</strong><br>
    2) <b>Declaration (hoisted):</b> function square(x){return x*x;}<br>
    3) Arrow function: const square1 = (x) => {return x*x;}; == const square2 = x=>x*x;<br>
    (single parameter and expression.)<br>
    Call Stack: Draw a table or flows; If call function is infinite, there is a error;
    Error: RangeError: Maximum call stack size exceeded.<br>
    Closure: being able to reference a specific instance of a local binding in an enclosing scope
    In other words, close over some local bindings<br>
    High-Order Function: more abstraction but decrease bugs;<br>
    Functions that operate on other functions, either by taking them as arguments or by returning them.<br>

    function repeat(n, action) {<br>
      &nbsp;&nbsp;for (let i = 0; i < n; i++) {<br>
      &nbsp;&nbsp;  action(i);<br>
      &nbsp;&nbsp;}<br>
    }<br>
    repeat(3, console.log);<br>
      <h4>Abstract over actions,not just values</h4>
      1) Create new function <br>
      2) 对内部for-loop参数i 执行一个新的函数; Have functions that change other functions<br>
      4) write functions that provide new types of control flow.<br>
  </p>
  <h3 id="C6">Chpater 6 Objects</h3>
  <a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html">阮一峰中文素材</a>
  <p>
    Encapsulation(封装性):Separating interface from implementation is a great idea. <br>
    Prototype(原型):A prototype is another object that is used as a fallback source of properties. <br>
    Obeject.create(); The function create a specifice prototype.<br>
    Class: 类是对象的模版，定义同一组对象（“实例”）共有的属性和方法；JavaScript一开始没有class，但是可以模拟一个类<br>
    Constructor: 构造函数 this 指代实例对象；new: 生成实例；类的属性和方法可以定义在prototype之上；<br>
  </p>
  <h3 id="C10">Chapter 10 Modules</h3>
  <p>
    Modules: 指实现某特定功能的一组方法和代码. eg: CommonJS，C “include”<br>
    模块模式使用了 JavaScript 的一个特性，即闭包（Closures) <br>
    模块的重要性：因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块.<br>
    要确保模块的合理分割则须了解信息隐藏，内聚度及耦合度。(dependencies, interface)<br>
    <a href="http://www.ruanyifeng.com/blog/javascript/">阮一峰老师的JavaScript</a><br>
    Important!<a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">Modules（1）</a><br>
    <a href="http://web.jobbole.com/83761/">模块化进程</a>
    <b>Dependencies：..waiting</b>
    基本模版：匿名闭包函数，能访问到全局变量，也叫立即执行函数，最外面需要括号包住。<br>
    参数是另一种全局变量的传入<br>
    (function (参数) { <br>
      &nbsp;&nbsp; // 模块代码 <br>
      &nbsp;&nbsp; // return something;<br>
    })(参数);）<br>
    第二种定义：对象接口<br>
      const weekDay = function() { <br>
        &nbsp;&nbsp; ../do something <br>
      }();<br>
    <h4>扩充 增加新的方法进去: ....waiting</h4>
    require（导入） to access their dependencies, and put their interface in the object
    bound to exports（导出）.<br>
    <b>JavaScript require()加载模块对象</b><br>
          每个模块实例都有一个require 方法<br>
          用来搜索文件或者文件夹的,调用模块<br>
          当 Node 遇到 require(X) 时，按下面的顺序处理。<br>
      （1）如果 X 是内置模块（比如 require('http'）) <br>
      　　a. 返回该模块。 <br>
      　　b. 不再继续执行。<br>
      （2）如果 X 以 "./" 或者 "/" 或者 "../" 开头 <br>
      　　a. 根据 X 所在的父模块，确定 X 的绝对路径。 <br>
      　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br>
      eg.const ordinal = require("ordinal"); //only single function;如果加载时间过长，后面
          程序无法进行，需要采取A异步加载，参见Chapter11<br>
          const {days, months} = require("date-names"); //an object containing multiple--—
          the two values we use are arrays of names. <br>
          <br>
          exports.formatDate = function(date, format) { //出口<br>
                  &nbsp;&nbsp; ../do something<br>
            &nbsp;});<br>
            };<br>
          const {formatDate} = require("./format-date");//接受出口<br>
      eg. change require to import(ES6 模块不是对象) <br>
      &nbsp;&nbsp; import ordinal from "ordinal"; <br>
      &nbsp;&nbsp; import {days, months} from "date-names";<br>
      &nbsp;&nbsp; export function formatDate(date, format) { /* ... */ }<br>
      export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口
      import用于在一个模块中加载另一个含有export接口的模块。
      eg. Import <br>
      import {firstName, lastName, year} from './profile';<br>
      function setName(element) {<br>
      &nbsp;&nbsp;  element.textContent = firstName + ' ' + lastName;<br>
      }<br>
      eg. Export <br>
      // export-default.js 之前的例子中，使用import导入时，都需要知道模块中所要加载的变量名或函数名，
      用户可能不想阅读源码，只想直接使用接口，就可以用export default命令，为模块指定输出<br>
      export default function () {<br>
        &nbsp; &nbsp; console.log('foo');<br>
      }<br>
      <h4>import {} from </h4>
      <a href="http://es6.ruanyifeng.com/#docs/module#export">阮一峰老师ECMAScript 6</a>
      export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口 <br>
      import用于在一个模块中加载另一个含有export接口的模块。<br>
      也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。<br>
    node.js规范了CommonJS
    1. 模块的标识应遵循的规则（书写规范）<br>
    2. 定义全局函数require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的API<br>
    3. 如果被require函数引入的模块中也包含依赖，那么依次加载这些依赖<br>
    4. 如果引入模块失败，那么require函数应该报一个异常<br>
    5. 模块通过变量exports来向往暴漏API，exports只能是一个对象，暴漏的API须作为此对象的属性。<br>
  </p>
  <h3 id="C11">Chapter 11 Asynchronous Programming</h3>
  <p>
    所谓"单线程"(Synchronous)，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务
    完成，再执行后面一个任务，以此类推。<br>
    异步的(Asynchronous): 每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行
    后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排
    列顺序是不一致的、异步的。
    <h4>Callback(high-order)</h4>
      eg:
      setTimeout()方法只运行一次，也就是说当达到设定的时间后就出发运行指定的代码，运行完后就结束了，
      如果还想再次执行同样的函数，可以在函数体内再次调用setTimeout()，可以达到循环调用的效果。
      setInterval()是循环执行的，即每达到指定的时间间隔就执行相应的函数或者表达式，是真正的定时器。
    <h4>Promise</h4>
    <a href="https://www.cnblogs.com/nullcc/p/5841182.html">Link to Asyn Pro</a><br>
    为CommonJS 提供统一的接口<br>
    <ul>
      <li>异步，表示在将来某一时刻执行，那么Promise也必须可以表示一个将来值；</li>
      <li>异步任务，可能成功也可能失败，则Promise需要能完成事件，标记其状态值（这个过程即决议-resolve，下文将详细介绍）；</li>
      <li>可能存在多重异步任务，即异步任务回调中有异步任务，所以Promise还需要支持可重复使用，添加异步任务（表现为顺序链式
        调用，注册异步任务，这些异步任务将按注册的顺序执行）。</li>
    </ul>
    Defintion:A promise is an asynchronous action that may complete at some point and
     produce a value.<br>
    Create a promise: 1) Promise.resolve(); 2) Constructor: new Promise(function(
    resolve, reject) {});<br>
    Method then(): get result;指定回调函数 (resolve,reject),then()方法可以有return;<br>
    There’s a Promise.reject function that creates a new, immediately-rejected promise.<br>
    eg. <br>
    <pre>
    <b>Important!</b><a href="https://juejin.im/post/597724c26fb9a06bb75260e8">Link to转载</a>
    1.Promise的立即执行性

    var p = new Promise(function(resolve, reject){
    console.log("create a promise");
    resolve("success");
    });

    console.log("after new Promise");

    p.then(function(value){
    console.log(value);
    });
    控制台输出：
    "create a promise"
    "after new Promise"
    "success"
    Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，
    只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，
    这是错误的。因此，代码中"create a promise"先于"after new Promise"输出。
    2.Promise 三种状态

    var p1 = new Promise(function(resolve,reject){
      resolve(1);
    });
    var p2 = new Promise(function(resolve,reject){
      setTimeout(function(){
        resolve(2);
      }, 500);
    });
    var p3 = new Promise(function(resolve,reject){
      setTimeout(function(){
        reject(3);
      }, 500);
    });

    console.log(p1);
    console.log(p2);
    console.log(p3);
    setTimeout(function(){
      console.log(p2);
    }, 1000);
    setTimeout(function(){
      console.log(p3);
    }, 1000);

    p1.then(function(value){
      console.log(value);
    });
    p2.then(function(value){
      console.log(value);
    });
    p3.catch(function(err){
      console.log(err);
    });
    控制台输出：

    Promise {[[PromiseStatus]]: "resolved", [[PromiseValue]]: 1}
    Promise {[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined}
    Promise {[[PromiseStatus]]: "pending", [[PromiseValue]]: undefined}
    1
    2
    3
    Promise {[[PromiseStatus]]: "resolved", [[PromiseValue]]: 2}
    Promise {[[PromiseStatus]]: "rejected", [[PromiseValue]]: 3}
    Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，
    处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在
    Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。

    p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1
    的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是
    resolved状态。我们通过两个setTimeout函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别
    变成resolved和rejected。
    </pre>
  </p>
  <p>
    <h4>Generator 函数</h4>
    最大的特点：交出函数的执行权 （暂停执行）！<br>
    yield: 异步操作需要暂停的地方 <br>
    Generator函数的函数名前面有一个"*" <br>
  </p>
  <p>
    <h4>async and await</h4>
    <a href="https://blog.csdn.net/sinat_17775997/article/details/76481923">Link to async</a>
    <a href="https://juejin.im/post/596e142d5188254b532ce2da">Link to asyn</a>
    async(异步) 函数变体 <br>
    async(异步) 函数总是返回 Promises 对象 <br>
    通过 await 处理 async(异步) 计算的结果和错误 <br>
    the word await can be put in front of an expression to wait for a promise to resolve,
     and only then continue the execution of the function.<br>
  </p>
</body>
</html>
